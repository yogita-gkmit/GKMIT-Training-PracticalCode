1. Singleton Pattern

BAD CODE

class Logger {
    constructor(name, age){
        console.log("Creating object");
        this.logMessages = [];
    }
	

	addMessage(message){
		this.logMessages.push(message);
		console.log(message);
	}
}

const log = new Logger("abc", 12);
log.addMessage("Hello World");
log.addMessage("Hellooooo");
log.addMessage("Worlddd");



GOOD CODE
let instance;

class Logger {
    constructor(name, age){
        this.logMessages = [];
        if(instance){
            throw new Error("You can only create one instance"); 
        }
        instance = this;
        
    }
	

	addMessage(message){
		this.logMessages.push(message);
		console.log(message);
	}
}

const log = new Logger("abc", 12);
log.addMessage("Hello World");
log.addMessage("Hellooooo");
log.addMessage("Worlddd");
const abc = new Logger("cde", 13);
abc.addMessage("hii");




2. Factory Pattern

BAD CODE

class Add {
    constructor(a, b){
        this.addition = a+b;
    }
    
    add(){
        console.log(this.addition);
    }
}

class Sub {
    constructor(a, b){
        this.subtraction = a-b;
    }
    
    sub(){
        console.log(this.subtraction);
    }
}

const ans = new Add(24, 13);
ans.add();

const result = new Sub(24,13);
result.sub();



GOOD CODE


class Add {
    constructor(a, b){
        this.addition = a+b;
    }
    
    add(){
        console.log(this.addition);
    }
}

class Sub {
    constructor(a, b){
        this.subtraction = a-b;
    }
    
    sub(){
        console.log(this.subtraction);
    }
}

class MathFactory {
    static math(operation, a, b){
        switch (operation){ 
            case 'Add': 
                this.ans = new Add(a,b);
                this.ans.add()
                return this.ans;
            break;
  
            case 'Sub': 
                this.ans = new Sub(a,b);
                return this.ans.sub();
            break;
        }
            
        }
}

const ans = MathFactory.math("Add", 24, 13);
const result = MathFactory.math("Sub", 24, 13);



3. Observer Pattern

BAD CODE


class Observable {
  constructor() {
    this.observers = [];
  }

  subscribe(func) {
    this.observers.push(func);
  }

  unsubscribe(func) {
    this.observers = this.observers.filter((observer) => observer !== func);
  }

  notify(data) {
    this.observers((observer) =>{ 
            console.log(observer(data));
            return observer(data)
        
    });

    // this is working only for single user, for multile users we have to make multiple notify functions
  }
}

const obj = new Observable();
let fun = (data)=>{
    return `subscriber 1 ${data}`;
}
obj.subscribe(fun);
// obj.unsubscribe(fun);
obj.notify("hey there!!");


GOOD CODE

class Observable {
  constructor() {
    this.observers = [];
  }

  subscribe(func) {
    this.observers.push(func);
  }

  unsubscribe(func) {
    this.observers = this.observers.filter((observer) => observer !== func);
  }

  notify(data) {
    this.observers.forEach((observer) =>{ 
            console.log(observer(data));
            return observer(data)
        
    });
  }
}

const obj = new Observable();
let fun = (data)=>{
    return `subscriber 1 ${data}`;
}
obj.subscribe(fun);
// obj.unsubscribe(fun);
obj.notify("hey there!!");



4. Decorator Pattern

BAD CODE

class Car {
    constructor() {
        this.price = 10000;
        this.description = "Basic Car";
    }
    getPrice() {
        return this.price;
    }
    getDescription() {
        return this.description;
    }
    addSunroof() {
        this.price += 1500;
        this.description += " with Sunroof";
    }
    addLeatherSeats() {
        this.price += 2000;
        this.description += " with Leather Seats";
    }
}
// Usage
const car = new Car();
car.addSunroof();
car.addLeatherSeats();
console.log(car.getPrice());
console.log(car.getDescription());
//GOOD CODE EXAMPLE:
class Car {
    getPrice() {
        return 10000;
    }
    getDescription() {
        return "Basic Car";
    }
}
class CarDecorator {
    constructor(car) {
        this.car = car;
    }
    getPrice() {
        return this.car.getPrice();
    }
    getDescription() {
        return this.car.getDescription();
    }
}
class SunroofDecorator extends CarDecorator {
    getPrice() {
        return this.car.getPrice() + 1500;
    }
    getDescription() {
        return this.car.getDescription() + " with Sunroof";
    }
}
class LeatherSeatsDecorator extends CarDecorator {
    getPrice() {
        return this.car.getPrice() + 2000;
    }
    getDescription() {
        return this.car.getDescription() + " with Leather Seats";
    }
}
let myCar = new Car();
myCar = new SunroofDecorator(myCar);
myCar = new LeatherSeatsDecorator(myCar);
console.log(myCar.getPrice());
console.log(myCar.getDescription());



/5. Logging Proxy
// Good example
const targetObject = {
  name: "John",
  age: 30,
  greet: function() {
    console.log(`Hello, I'm ${this.name}`);
  }
};
const loggingProxy = new Proxy(targetObject, {
  get(target, prop, receiver) {
    console.log(`Accessing property: ${prop}`);
    return Reflect.get(target, prop, receiver);
  },
  set(target, prop, value, receiver) {
    console.log(`Setting property: ${prop} to ${value}`);
    return Reflect.set(target, prop, value, receiver);
  }
});
loggingProxy.name = "Jane"; // Logs: Setting property: name to Jane
loggingProxy.greet(); // Logs: Accessing property: greet, Hello, I'm Jane
// Bad example: Overcomplicated Proxy
const target = {};
const proxy = new Proxy(target, {
  get(target, prop) {
    if (prop === 'foo') {
      // Complex logic here...
    } else if (prop === 'bar') {
      // More complex logic...
    }
    // ...
  },
  set(target, prop, value) {
    if (prop === 'foo') {
      // Even more complex logic...
    }
    // ...
  }
});
// 6. Command Pattern
// Good example
class Light {
  constructor() {
    this.isOn = false;
  }
  on() {
    this.isOn = true;
    console.log('Light is on');
  }
  off() {
    this.isOn = false;
    console.log('Light is off');
  }
}
class LightOnCommand {
  constructor(light) {
    this.light = light;
  }
  execute() {
    this.light.on();
  }
}
class LightOffCommand {
  constructor(light) {
    this.light = light;
  }
  execute() {
    this.light.off();
  }
}
const light = new Light();
const lightOnCommand = new LightOnCommand(light);
const lightOffCommand = new LightOffCommand(light);
const remoteControl = {
  executeCommand: function(command) {
    command.execute();
  }
};
remoteControl.executeCommand(lightOnCommand);
remoteControl.executeCommand(lightOffCommand);
// Bad example
function turnLightOn() {
  console.log('Light is on');
}
function turnLightOff() {
  console.log('Light is off');
}
const remoteControl = {
  on: turnLightOn,
  off: turnLightOff
};
remoteControl.on();
remoteControl.off();










